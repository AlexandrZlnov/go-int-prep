// Задача:
// Есть самописный WaitGroup
// Какие есть проблемы у данной реализации, как их исправить?

package main

import (
	"sync"
)

type WaitGroup struct {
	mu sync.RWMutex
}

func (w *WaitGroup) Go(f func()) {
	go func() {
		w.mu.RLock()
		f()
		w.mu.RUnlock()
	}()
}

func (w *WaitGroup) Wait() {
	w.mu.Lock()
	w.mu.Unlock()
}

// Ответ:

// Несмотря на название, эта реализация не является WaitGroup.
// По поведению она ближе к некорректному использованию RWMutex,
// так как блокировка удерживается на время выполнения функции,
// а Wait() просто пытается получить эксклюзивный lock,
// не имея счётчика и гарантий ожидания завершения горутин.

// Проблема №1: Wait() не гарантирует ожидание всех горутин

// Проблема №2: RWMutex используется не по назначению
// RWMutex предназначен для: защиты разделяемых данных когда есть читатели и писатели
// Здесь: нет данных нет состояния mutex используется как счётчик, что является антипаттерном

// Проблема №3: Возможен дедлок
// Если Wait() возьмёт Lock() раньше:
// Wait() -> Lock()
// goroutine -> RLock() // блокируется навсегда
// ➡ Wait() ждёт RUnlock, которого не будет
// ➡ дедлок

// Проблема №4: Нельзя переиспользовать
// В нормальном sync.WaitGroup:
// Add() увеличивает счётчик
// Done() уменьшает
// Wait() ждёт, пока счётчик станет 0
// Здесь: нет счётчика нет состояния нет защиты от повторного использования

// Проблема №5: Паника в f() ломает всё
// Если f() паникует:
// w.mu.RLock()
// f() // panic
// w.mu.RUnlock() // не выполнится
// ➡ Wait() зависнет навсегда

// Сводный ответ:
// В данной реализации WaitGroup:
// - отсутствует счётчик активных горутин
// - Wait() не гарантирует ожидание завершения всех задач
// - RWMutex используется не по назначению
// - возможны гонки и дедлоки
// - паника в горутине приводит к вечной блокировке
// - Корректная реализация должна либо использовать счётчик (atomic + mutex),
// либо канал, либо просто sync.WaitGroup.

// Минимальный правильный вариант (каналами, без sync)

type *WaitGroup struct {
	ch chan struct{}
}

func New() {
	return &WaitGroup{ch: make(chan struct{})}
}

func (w *WaitGroup) Go(f func()) {
	go func() {
		defer func() {
			w.ch <- struct{}{}
		}()
		f()
	}()
}

func (w *WaitGroup) Wait() {
	for i:=0; i<n; i++ {
		<- w.ch
	}
}
