/*
------------------------------------------------------1 задание
100 баллов
Ограничение времени
1 секунда
Ограничение памяти
256 МБ
Дана строка
s
s, которая содержит только цифры от
0
0 до
9
9, в которой не все элементы равны
0
0. Нужно переставить в ней цифры таким образом, чтобы число, которое представляет данная строка, было минимально возможным, а также чтобы в этой строке не было ведущих нулей.

Число содержит ведущие нули, если число не равно нулю, но при этом в начале числа стоит цифра
0
0. Так, например, числа
01
01,
0303
0303 содержат ведущие нули, тогда как
0
0,
30000
30000 нет.

Входные данные
В единственной строке задана строка
s
s (
1
≤
∣
s
∣
≤
9
1≤∣s∣≤9). Гарантируется, что в этой строке есть элемент, отличный от
0
0.

Выходные данные
В единственной строке выведите ровно одну строку — строку, которая представляет собой минимально возможное число без ведущих нулей.

Примеры данных
Пример 1
682902

682902
Ввод
202689

202689
Вывод
Пример 2
01

01
Ввод
10

10
Вывод

*/

/* Вар 1

package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	in := bufio.NewReader(os.Stdin)

	var s string
	fmt.Fscan(in, &s)

	count := make([]int, 10)
	hasNonZero := false

	for i := 0; i < len(s); i++ {
		d := s[i] - '0'
		count[d]++
		if d != 0 {
			hasNonZero = true
		}
	}

	if !hasNonZero {
		fmt.Println("Ошибка: строка должна содержать хотя бы одну цифру, отличную от 0")
		return
	}

	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	for d := 1; d <= 9; d++ {
		if count[d] > 0 {
			out.WriteByte(byte('0' + d))
			count[d]--
			break
		}
	}

	for d := 0; d <= 9; d++ {
		for count[d] > 0 {
			out.WriteByte(byte('0' + d))
			count[d]--
		}
	}
}

*/

package main

import (
	"fmt"
)

func main() {
	var s string
	fmt.Scan(&s)

	count := [10]int{}
	hasNonZero := false

	for i := 0; i < len(s); i++ {
		d := s[i] - '0'
		count[d]++
		if d != 0 {
			hasNonZero = true
		}
	}

	if !hasNonZero {
		fmt.Println("Ошибка: строка должна содержать хотя бы одну цифру, отличную от 0")
		return
	}

	for d := 1; d <= 9; d++ {
		if count[d] > 0 {
			fmt.Print(d)
			count[d]--
			break
		}
	}

	for d := 0; d <= 9; d++ {
		for count[d] > 0 {
			fmt.Print(d)
			count[d]--
		}
	}
}
